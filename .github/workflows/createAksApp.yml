name: Create AKS App

# Controls when the workflow will run
on:
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
    inputs:
      appname:
        description: Application Name
        required: true
      pvc:
        description: Persistent Volume size (default, 1Gi)
        required: true
        default: 1

permissions:
  id-token: write
  contents: read
#  actions: read

env:
  APP_NAME: aks-app-${{ inputs.appname }}
  ACR_REPO: aks-app/${{ inputs.appname }}

jobs:

  initCheck:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest
    outputs:
      app_check: ${{ steps.app_check.outputs.status }}
      ns_check: ${{ steps.ns_check.outputs.status }}
      acrrepo_check: ${{ steps.acrrepo_check.outputs.status }}
      acrtoken_check: ${{ steps.acrtoken_check.outputs.status }}
      githubrepo_check: ${{ steps.githubrepo_check.outputs.status }}

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
    - name: Azure login OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

    - name: kubelogin with AKS
      uses: azure/use-kubelogin@v1
      with:
        kubelogin-version: 'v0.0.34'

    - name: Set AKS context
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ vars.AKS_RESOURCE_GROUP }}
        cluster-name: ${{ vars.AKS_CLUSTER }}
        admin: false
        use-kubelogin: true

    - name: Check Azure App
      id: app_check
      run: echo "status=$(az ad app list --filter "displayname eq '${{ env.APP_NAME }}'" --output tsv | wc -l)" >> $GITHUB_OUTPUT

    - name: Check AKS namespace
      id: ns_check
      run: echo "status=$(kubectl get namespace ${{ env.APP_NAME }} --ignore-not-found --no-headers | wc -l)" >> $GITHUB_OUTPUT

    - name: Check ACR repository
      id: acrrepo_check
      run: echo "status=$(az acr repository list -n ${{ vars.ACR_REGISTRY }} --query "[?contains(@, '${{ env.ACR_REPO }}')]" --output tsv | wc -l)" >> $GITHUB_OUTPUT

    - name: Check ACR token
      id: acrtoken_check
      run: echo "status=$(az acr token list -r ${{ vars.ACR_REGISTRY }} --query "[?name == '${{ env.APP_NAME }}'].name" --output tsv | wc -l)" >> $GITHUB_OUTPUT

    - name: Check Github repository
      id: githubrepo_check
      run: echo "status=$(gh repo list ${{ vars.GH_ORG }} --json name | grep '\"${{ env.APP_NAME }}\"' | wc -l)" >> $GITHUB_OUTPUT
      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN }}

    - name: Display check status
      run: |
        echo "App check: ${{ steps.app_check.outputs.status }}"
        echo "Namespace check: ${{ steps.ns_check.outputs.status }}"
        echo "ARC repository check: ${{ steps.acrrepo_check.outputs.status }}"
        echo "ACR token check: ${{ steps.acrtoken_check.outputs.status }}"
        echo "Github repository check: ${{ steps.githubrepo_check.outputs.status }}"


  deploy:
    runs-on: ubuntu-latest
    needs: initCheck
    # only run this step if all checks return false
    if: |-
      ${{
        needs.initCheck.outputs.app_check == '0' &&
        needs.initCheck.outputs.ns_check == '0' &&
        needs.initCheck.outputs.acrtoken_check == '0' &&
        needs.initCheck.outputs.acrtoken_check == '0' &&
        needs.initCheck.outputs.githubrepo_check == '0'
      }}

    steps:
    - name: Checkout the repository
      uses: actions/checkout@v4

    - name: Replace token with env variables
      uses: cschleiden/replace-tokens@v1
      with:
        tokenPrefix: '#{'
        tokenSuffix: '}#'
        files: '["./federated-credential.json", "./ResourceQuota.yaml", "./PersistentVolumeClaim.yaml"]'
      env:
        APP_NAME: ${{ env.APP_NAME }}
        GH_ORG: ${{ vars.GH_ORG }}
        PVC_SIZE: ${{ inputs.pvc }}

    - name: Azure login OIDC
      uses: azure/login@v1
      with:
        client-id: ${{ secrets.AZURE_CLIENT_ID }}
        tenant-id: ${{ secrets.AZURE_TENANT_ID }}
        subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
    
    - name: kubelogin with AKS
      uses: azure/use-kubelogin@v1
      with:
        kubelogin-version: 'v0.0.34'

    - name: Set AKS context
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ vars.AKS_RESOURCE_GROUP }}
        cluster-name: ${{ vars.AKS_CLUSTER }}
        admin: false
        use-kubelogin: true

    - name: Register an App
      run: echo "AZURE_APP_ID=$(az ad app create --display-name ${{ env.APP_NAME }} --query "appId" --output tsv)" >> $GITHUB_ENV

    - name: Add App owner
      run: az ad app owner add --id ${{ env.AZURE_APP_ID }} --owner-object-id b14a3839-eae6-453b-a37f-0e12ff845aa4

    - name: Create Federated Credential
      run: az ad app federated-credential create --id ${{ env.AZURE_APP_ID }} --parameters federated-credential.json

    - name: Create ACR repository token
      run: echo "ACR_TOKEN_PW=$(az acr token create --name "${{ env.APP_NAME }}" --registry ${{ vars.ACR_REGISTRY }} --repository ${{ env.ACR_REPO }} content/delete content/read content/write metadata/read --only-show-errors --query "credentials.passwords[?name=='password1'].value" --output tsv)" >> $GITHUB_ENV

    - name: Create AKS namespace, apply resource quota, network policy and PVC
      run: |
        kubectl create namespace ${{ env.APP_NAME }}
        kubectl apply -f ./NetworkPolicy.yaml -f ./ResourceQuota.yaml -f ./PersistentVolumeClaim.yaml -n ${{ env.APP_NAME }}
        sleep 5
        echo "AKS_PVC=$(kubectl get pvc ${{ env.APP_NAME }}-pvc -o=custom-columns="volume:.spec.volumeName" --no-headers -n ${{ env.APP_NAME }})" >> $GITHUB_ENV

#     comment: use policy to control SAS
#     az storage share policy create --name ${{ env.APP_NAME }} --share-name ${{ env.AKS_PVC }} --expiry 2047-06-30T16:00:00Z --permissions cdlrw
#     echo "AZURE_SA_SAS=$(az storage share generate-sas --name ${{ env.AKS_PVC }} --policy-name ${{ env.APP_NAME }} --output tsv)" >> $GITHUB_ENV
    - name: Create file share SAS
      run: |
        echo "AZURE_SA_SAS=$(az storage share generate-sas --name ${{ env.AKS_PVC }} --expiry 2047-06-30T16:00Z --permissions cdlrw --output tsv)" >> $GITHUB_ENV
      env:
        AZURE_STORAGE_KEY: ${{ secrets.AZURE_SA_KEY }}
        AZURE_STORAGE_ACCOUNT: ${{ vars.AZURE_SA }}

    - name: Create Github repository
      run: |
        gh repo create ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --template ${{ vars.GH_ORG }}/aks_template --private
        gh secret set ACR_TOKEN --repo ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --body "$ACR_TOKEN"
        gh secret set ACR_USER --repo ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --body "$ACR_USER"
        gh secret set AZURE_CLIENT_ID --repo ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --body "$AZURE_CLIENT_ID"
        gh secret set AZURE_SUBSCRIPTION_ID --repo ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --body "$AZURE_SUBSCRIPTION_ID"
        gh secret set AZURE_TENANT_ID --repo ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --body "$AZURE_TENANT_ID"
        gh variable set ACR_REGISTRY --repo ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --body "$ACR_REGISTRY"
        gh variable set ACR_REPO --repo ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --body "$ACR_REPO"
        gh variable set AKS_CLUSTER --repo ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --body "$AKS_CLUSTER"
        gh variable set AKS_RESOURCE_GROUP --repo ${{ vars.GH_ORG }}/${{ env.APP_NAME }} --body "$AKS_RESOURCE_GROUP"
      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN }}
        ACR_TOKEN: ${{ env.ACR_TOKEN_PW }}
        ACR_USER: ${{ env.APP_NAME }}
        AZURE_CLIENT_ID: ${{ env.AZURE_APP_ID }}
        AZURE_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
        AZURE_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
        ACR_REGISTRY: acrakszup2kwh4fwbse.azurecr.io
        ACR_REPO: ${{ env.ACR_REPO }}
        AKS_CLUSTER: aks-zup2kwh4fwbse
        AKS_RESOURCE_GROUP: rg-dev-eas-aks-01

    - name: Run Github repository actions
      run: |
        gh workflow run clone_image.yml -f image=mysql -f tag=8.2.0 -R ${{ vars.GH_ORG }}/${{ env.APP_NAME }}
        gh workflow run clone_image.yml -f image=php -f tag=php_zts-alpine3.19 -R ${{ vars.GH_ORG }}/${{ env.APP_NAME }}
      env:
        GH_TOKEN: ${{ secrets.GH_TOKEN }}

    - name: Debug
      run: |
        cat ./federated-credential.json
        echo "App Name: ${{ env.APP_NAME }}"
        echo "App ID: ${{ env.AZURE_APP_ID }}"
        echo "PVC Name: ${{ env.AKS_PVC }}"
        echo "Share SAS: ${{ env.AZURE_SA_SAS }}"
